---
title: 前端面试题-js篇
date: 2024-02-27 10:06:39
permalink: /pages/052243/
categories:
  - 更多
  - 面试
tags:
  - 
---
## JS经典面试题系列
> 这里收录一些js的经典面试题，涉及到js的方方面面

1. for循环
```js
for(var i = 1;i<=5;i++){
    setTimeout(()=>{
        console.log(i)
    },0)
}
//输出 6,6,6,6,6

for(let i = 1;i<=5;i++){
    setTimeout(()=>{
        console.log(i)
    },0)
}
//输出 1,2,3,4,5
```
上面这两段代码 为什么``var``会输出``5个6`` 换成``let``后就能正确输出``1，2，3，4，5``呢？

``var``声明的变量会提升，因此代码中的``i``会被提升为``全局``变量，作用域不止在``for``循环中。根据事件循环机制，
定时器会在``for``循环全部执行完毕之后再执行，当``for``循环执行完成后，由于都是对同一个``i``去自增，所以这时定时器
中访问的``i``就是自增``5``次后的``i``。所以会连续输出``5个6``。

而在``let``不存在变量提升，所以每次迭代都会执行一遍``let i = 1`` ，并且``for``循环会记住上一次迭代的值并将他赋值给``i``
这样每次迭代执行的定时器都会访问到一个新的``i``，并且这个``i``的值还是上一次迭代后的结果。所以可以正确的输出``1,2,3,4,5``

如果不使用``let`` 还有没有别的办法呢？

其实这里主要考验的就是作用域和事件循环机制，为什么``var``不行？因为``var``声明的``i``作用域是全局的，导致定时器最后访问的都是同一个``i``。
而我们其实只要保证定时器每次访问的``i``是一个独立的变量一个作用域为定时器内的就行了。

```js
for(var i = 1;i<=5;i++){
    (function (j){
        setTimeout(()=>{
            console.log(j)
        },0)
    }) (i)
}
```
这里我们用一个``自执行函数``，将每次迭代后的``i``作为参数传进去，这样函数体内接受到的形参就是一个独立的值（根据函数参数是值传递的原理）。
定时器也每次也就会访问到只属于这个自执行函数作用域内的``i``了。

