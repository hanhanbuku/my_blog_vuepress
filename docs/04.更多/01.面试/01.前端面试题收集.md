---
title: 前端面试题收集
date: 2024-02-27 10:06:39
permalink: /pages/052243/
categories:
  - 更多
  - 面试
tags:
  - 
---
## HTML、CSS
> 这里收录一些html、css的经典面试题

### 1.盒模型
::: tip 答案

盒模型是css3中提出的对于元素大小描述的概念：概念中指出把每一个元素都比喻成一个盒子，他们有各自的宽高。
css3中盒模型分为两种：标准盒模型、怪异盒模型

盒模型一共由四个部分组成：margin、padding、border、content。两种盒模型的区别如下：

- 标准盒模型：
  -  在dom结构中实际占用 = width + padding + border + margin
  -  实际宽度 = width + padding + border
- 怪异盒模型：
  -  在dom结构中实际占用 = width + margin
  -  实际宽度 = width

修改盒模型可以通过box-sizing来实现：
- box-sizing: content-box表示标准盒模型
- box-sizing: border-box表示 IE 盒模型

:::

### 2.响应式布局

- 使用css媒体查询：根据不同的屏幕尺寸写不同的样式
- flex弹性盒子
- 流媒体布局：使用百分比来设置宽高
- 采用css相对单位

### 3.说一说flexible的实现原理
::: tip 答案

flexible是淘宝移动端的响应式适配方案，通过动态计算根元素的字体大小+使用rem作为css尺寸单位来实现适配不同分辨率的屏幕。
- 动态计算根元素的字体大小
  - 根据设备的dpr（设备像素比）值来计算html根元素的字体大小，公式：html的字体大小=基准字体大小×缩放比例，基准字体大小是一个预先设定的值，它对应于基准dpr（通常是1）时的字体大小。缩放比例是当前dpr与基准dpr的比值。
- px转rem
  - rem = px / 根元素字体大小 

:::




## JS
> 这里收录一些js的经典面试题，涉及到js的方方面面

### 1.for循环
```js
for(var i = 1;i<=5;i++){
    setTimeout(()=>{
        console.log(i)
    },0)
}
//输出 6,6,6,6,6

for(let i = 1;i<=5;i++){
    setTimeout(()=>{
        console.log(i)
    },0)
}
//输出 1,2,3,4,5
```
上面这两段代码 为什么``var``会输出``5个6`` 换成``let``后就能正确输出``1，2，3，4，5``呢？

``var``声明的变量会提升，因此代码中的``i``会被提升为``全局``变量，作用域不止在``for``循环中。根据事件循环机制，
定时器会在``for``循环全部执行完毕之后再执行，当``for``循环执行完成后，由于都是对同一个``i``去自增，所以这时定时器
中访问的``i``就是自增``5``次后的``i``。所以会连续输出``5个6``。

而在``let``不存在变量提升，所以每次迭代都会执行一遍``let i = 1`` ，并且``for``循环会记住上一次迭代的值并将他赋值给``i``
这样每次迭代执行的定时器都会访问到一个新的``i``，并且这个``i``的值还是上一次迭代后的结果。所以可以正确的输出``1,2,3,4,5``

如果不使用``let`` 还有没有别的办法呢？

其实这里主要考验的就是作用域和事件循环机制，为什么``var``不行？因为``var``声明的``i``作用域是全局的，导致定时器最后访问的都是同一个``i``。
而我们其实只要保证定时器每次访问的``i``是一个独立的变量一个作用域为定时器内的就行了。

```js
for(var i = 1;i<=5;i++){
    (function (j){
        setTimeout(()=>{
            console.log(j)
        },0)
    }) (i)
}
```
这里我们用一个``自执行函数``，将每次迭代后的``i``作为参数传进去，这样函数体内接受到的形参就是一个独立的值（根据函数参数是值传递的原理）。
定时器也每次也就会访问到只属于这个自执行函数作用域内的``i``了。

## Vue
> 这里收录一些vue的面试题，包括vue2和vue3

### 1.vue3 为什么需要用reflect配合proxy使用
::: tip 答案

``Reflect``是一个内置的全局对象，它提供了拦截 ``JavaScript`` 操作的方法。``Reflect`` 对象的方法与 ``Proxy`` 处理的陷阱（``trap``）一一对应。使用`` Reflect ``的主要原因是为了保持与普通对象操作的一致性。
``Reflect``确保了即使在 ``Proxy`` 拦截了某些操作的情况下，对象的默认行为也能被保持，同时提供了一种避免代码重复和确保兼容性的方法。

:::
### 2.watch和computed是否可以异步，为什么？
::: tip 答案

``watch``支持异步，``computed``不支持异步：``watch``的回调支持异步是因为他的触发之后就已经脱离了依赖项，在检测到依赖项变化后会触发回调函数，此时回调函数即使是异步也不会影响到什么。而``computed``不支持异步是因为其内部存在的缓存机制，如果回调是异步的话那么缓存机制就无法拿到最新的值，会永远返回缓存的旧值。

:::
### 3.vue2.x 和 vuex3.x 渲染器的 diff 算法分别说一下？
::: tip 答案

简单来说，``diff``算法有以下过程

- 同级比较，再比较子节点
- 先判断一方有子节点一方没有子节点的情况(如果新的``children``没有子节点，将旧的子节点移除)
- 比较都有子节点的情况(核心``diff``)
- 递归比较子节点

正常``Diff``两个树的时间复杂度是``O(n^3)``，但实际情况下我们很少会进行跨层级的移动``DOM``，所以``Vue``将``Diff``进行了优化，从``O(n^3) -> O(n)``，只有当新旧``children``都为多个子节点时才需要用核心的``Diff``算法进行同层级比较。

``Vue2``的核心``Diff``算法采用了双端比较的算法，同时从新旧``children``的两端开始进行比较，借助``key``值找到可复用的节点，再进行相关操作。相比``React``的``Diff``算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。

``Vue3.x``借鉴了 ``ivi``算法和 ``inferno``算法

在创建``VNode``时就确定其类型，以及在``mount/patch``的过程中采用位运算来判断一个``VNode``的类型，在这个基础之上再配合核心的``Diff``算法，使得性能上较``Vue2.x``有了提升。(实际的实现可以结合``Vue3.x``源码看。)
该算法中还运用了动态规划的思想求解``最长递增子序列``。

:::
### 4.keep-alive的原理
::: tip 答案

keep-alive可以实现组件的缓存，当组件切换时不会对当前组件进行卸载
其内部主要采用了缓存淘汰策略来实现

:::
### 5.nextTick的作用是什么？实现原理？
::: tip 答案

nextTick会在dom更新结束之后执行回调，主要是利用了宏任务微任务的执行顺序不同来实现的，根据当前环境支持成都不同以降级的方式采用以下几个api
- Promise
- MutationObserver
- setImmediate
- 如果以上都不行则采用setTimeout


:::

## React
> 这里收录一些react的面试题

## 工程化
> 这里收录一些工程化的面试题

### 1.webpack中file-loader和url-loader的区别

二者都是用于处理文件，url-loader时file-loader的封装
- file-loader: 不对文件进行处理只用于复制文件，将文件复制到目标路径下
- url-loader：可以将小文件转成base64格式

### 2.webpack和vite的区别
``webpack``和``vite``都是现代工程化构建工具，二者出于不同的设计理念。主要区别在于开发环境

开发环境：``webpack``本质上是一个模块打包器，他把项目中的所有模块都打包成一个或者多个``bundle``，在处理大项目时由于``webpack``需要构建完所有模块才能产出构建产物，所以通常来说速度会很慢，而``vite``
采用浏览器支持``esmodule``导入的特性，在开发阶段只对依赖进行与构建（产出每个依赖和他的路径的映射表）。在浏览器需遇到``import``语句的时候会去发起请求，``vite``这时动态的去构建被请求的文件 并且响应给浏览器由此完成整个链路。
也就是说``vite``并不需要在项目启动时就构建完所有的文件 而是浏览器用到了哪个他才去构建哪个，这也就是为什么``vite``开发环境速度飞快的原因。

生产环境：``vite``生产环境和``webpack``大同小异，也是需要构建所有的产物，值得注意的时``vite``在生产环境采用的时``rollup``，而开发环境采用的时``esbuild``去构建

### 3.vite衍生问题：esbuild和rollup的区别
``esbuild``由``GO``编写，速度由于``rollup``，并且他对跨平台的支持和多语言的支持更加良好，使用起来简单。``rollup``是一个专注``es``模块的打包器，它使用``es``语法来打包代码，他的摇树优化非常优秀，打包速度也很快并且支持输出不同格式的模块代码如``ESM``,``CommonJS``,``UMD``。
``vite``在开发环境选择``esbuild``是为了快速相应浏览器的请求，而生产阶段用``rollup``则是更好的支持构建。



## 浏览器
>浏览器相关面试题


### 1.什么是强缓存和协商缓存

浏览器缓存是提升用户体验和减轻服务器压力的重要手段，这其中包括``强缓存``和``协商缓存``两种：
- 强缓存：``强缓存``是通过``Expires``和``Cache-Control``来实现的，当浏览器请求一个资源的时候会先判断是否命中``强缓存``，是则直接使用本地缓存的内容
  - ``Expires``： 这是``http1.0``的头部，用来指定资源到期时间，浏览器会根据这个时间判断是否需要更新资源
  - ``Cache-Control``： 这事``http1.1``新增的头部，由于``Expires``不够灵活，所以新增了这个头部，来提供更灵活的配置：如``max-age：3600``（表示资源能够被缓存多久），``no-cache``（标识不缓存资源）。``Cache-Control``的优先级高于``Expires``


- 协商缓存：当``强缓存``没有命中时，浏览器会使用``协商缓存``，这个时候就需要跟服务器进行交互了。服务器在响应式会带上``Last-Modified``或``ETag``这两个头部信息。
  - ``Last-Modified / If-Modified-Since``： ``Last-Modified``表示资源最后一次修改的时间``If-Modified-Since``表示上次请求时的``最后修改时间``，也就是服务器返回的``Last-Modified``。由此让服务器判断是否更新了资源。
  - ``ETag / If-None-Match``：``ETag``表示资源的``唯一标识``，浏览器再次请求时会携带``If-None-Match``，``If-None-Match``就是上次请求时服务器返回的资源的``ETag``，通过这种方式让服务器判断是否需要更新资源。

::: tip 总结

强缓存主要通过``Expires(资源到期时间)``和``Cache-Control(内涵很多字段并且可设置不缓存)``来实现，这两个字段都由``服务器返回``，``浏览器自行判断``。此时浏览器和服务器``不进行``资源交换。协商缓存通过``Last-Modified / If-Modified-Since``和``ETag / If-None-Match``这两对来和服务器进行交互，简单来说就是服务器返回一个字段给浏览器，浏览器下次请求时携带上这个字段，由服务器来判断是否需要更新资源，如不需要服务器会相应``304（Not Modified）``状态码，如需要则返回新的资源。

:::

### 2.cookie和session
这两个都是用来跟踪验证用户信息的手段
- cookie：
  - 由服务端生成，通过http协议发送给客户端，客户端存储后在每次请求时携带上
  - 大小受限，一般不超过4kb
  - 可以跨页面访问
- session：
  - 由服务器生成，存储与服务器。每个用户都会被分配一个唯一的Session ID，该ID通过Cookie或URL重写的方式发送给客户端浏览器，并在后续的请求中携带。
  - 可以存储更多数据
  - 可以跨页面访问

关闭浏览器后 两者会有何变化
- 会话级cookie（没设置过期时间）会被销毁
- 持久级cookie（设置了过期时间）不会被销毁
- session会被销毁，由于session是由浏览器当前窗口记录sessionID来何服务器交互的所以即使没有关闭当前窗口 新开一个窗口 session也会失效

### 3.cookie是否可以跨域名使用

::: tip 答案

是可以的，但是需要配置domain主域名的形式来实现，不同的域名必须归属于同一主域名下才可以实现cookie的跨域名访问

:::

### 4.cdn为什么不会受同源策略影响

::: tip 答案

浏览器的同源策略限制了网络请求必须相同协议，相同ip，相同的端口。但是cdn通常会何当前域名不同源，他没有受影响主要是
因为cdn一般通过script标签或者img标签或者link标签加载。通过标签的src属性发送的请求不会受同源策略影响，jsonp解决跨域问题也是利用了这个原理

:::



## 计算机网络
> 这里收录一些计算机网络的面试题





