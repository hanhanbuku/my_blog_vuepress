---
title: 前端面试题收集
date: 2024-02-27 10:06:39
permalink: /pages/052243/
categories:
  - 更多
  - 面试
tags:
  - 
---
## JS
> 这里收录一些js的经典面试题，涉及到js的方方面面

### for循环
```js
for(var i = 1;i<=5;i++){
    setTimeout(()=>{
        console.log(i)
    },0)
}
//输出 6,6,6,6,6

for(let i = 1;i<=5;i++){
    setTimeout(()=>{
        console.log(i)
    },0)
}
//输出 1,2,3,4,5
```
上面这两段代码 为什么``var``会输出``5个6`` 换成``let``后就能正确输出``1，2，3，4，5``呢？

``var``声明的变量会提升，因此代码中的``i``会被提升为``全局``变量，作用域不止在``for``循环中。根据事件循环机制，
定时器会在``for``循环全部执行完毕之后再执行，当``for``循环执行完成后，由于都是对同一个``i``去自增，所以这时定时器
中访问的``i``就是自增``5``次后的``i``。所以会连续输出``5个6``。

而在``let``不存在变量提升，所以每次迭代都会执行一遍``let i = 1`` ，并且``for``循环会记住上一次迭代的值并将他赋值给``i``
这样每次迭代执行的定时器都会访问到一个新的``i``，并且这个``i``的值还是上一次迭代后的结果。所以可以正确的输出``1,2,3,4,5``

如果不使用``let`` 还有没有别的办法呢？

其实这里主要考验的就是作用域和事件循环机制，为什么``var``不行？因为``var``声明的``i``作用域是全局的，导致定时器最后访问的都是同一个``i``。
而我们其实只要保证定时器每次访问的``i``是一个独立的变量一个作用域为定时器内的就行了。

```js
for(var i = 1;i<=5;i++){
    (function (j){
        setTimeout(()=>{
            console.log(j)
        },0)
    }) (i)
}
```
这里我们用一个``自执行函数``，将每次迭代后的``i``作为参数传进去，这样函数体内接受到的形参就是一个独立的值（根据函数参数是值传递的原理）。
定时器也每次也就会访问到只属于这个自执行函数作用域内的``i``了。

## Vue
> 这里收录一些vue的面试题，包括vue2和vue3

### vue3 为什么需要用reflect配合proxy使用
::: tip 答案

``Reflect``是一个内置的全局对象，它提供了拦截 ``JavaScript`` 操作的方法。``Reflect`` 对象的方法与 ``Proxy`` 处理的陷阱（``trap``）一一对应。使用`` Reflect ``的主要原因是为了保持与普通对象操作的一致性。
``Reflect``确保了即使在 ``Proxy`` 拦截了某些操作的情况下，对象的默认行为也能被保持，同时提供了一种避免代码重复和确保兼容性的方法。

:::
### watch和computed是否可以异步，为什么？
::: tip 答案

``watch``支持异步，``computed``不支持异步：``watch``的回调支持异步是因为他的触发之后就已经脱离了依赖项，在检测到依赖项变化后会触发回调函数，此时回调函数即使是异步也不会影响到什么。而``computed``不支持异步是因为其内部存在的缓存机制，如果回调是异步的话那么缓存机制就无法拿到最新的值，会永远返回缓存的旧值。

:::

## 浏览器
>浏览器相关面试题
### 什么是强缓存和协商缓存

浏览器缓存是提升用户体验和减轻服务器压力的重要手段，这其中包括``强缓存``和``协商缓存``两种：
- 强缓存：``强缓存``是通过``Expires``和``Cache-Control``来实现的，当浏览器请求一个资源的时候会先判断是否命中``强缓存``，是则直接使用本地缓存的内容
  - ``Expires``： 这是``http1.0``的头部，用来指定资源到期时间，浏览器会根据这个时间判断是否需要更新资源
  - ``Cache-Control``： 这事``http1.1``新增的头部，由于``Expires``不够灵活，所以新增了这个头部，来提供更灵活的配置：如``max-age：3600``（表示资源能够被缓存多久），``no-cache``（标识不缓存资源）。``Cache-Control``的优先级高于``Expires``


- 协商缓存：当``强缓存``没有命中时，浏览器会使用``协商缓存``，这个时候就需要跟服务器进行交互了。服务器在响应式会带上``Last-Modified``或``ETag``这两个头部信息。
  - ``Last-Modified / If-Modified-Since``： ``Last-Modified``表示资源最后一次修改的时间``If-Modified-Since``表示上次请求时的``最后修改时间``，也就是服务器返回的``Last-Modified``。由此让服务器判断是否更新了资源。
  - ``ETag / If-None-Match``：``ETag``表示资源的``唯一标识``，浏览器再次请求时会携带``If-None-Match``，``If-None-Match``就是上次请求时服务器返回的资源的``ETag``，通过这种方式让服务器判断是否需要更新资源。

::: tip 总结  

强缓存主要通过``Expires(资源到期时间)``和``Cache-Control(内涵很多字段并且可设置不缓存)``来实现，这两个字段都由``服务器返回``，``浏览器自行判断``。此时浏览器和服务器``不进行``资源交换。协商缓存通过``Last-Modified / If-Modified-Since``和``ETag / If-None-Match``这两对来和服务器进行交互，简单来说就是服务器返回一个字段给浏览器，浏览器下次请求时携带上这个字段，由服务器来判断是否需要更新资源，如不需要服务器会相应``304（Not Modified）``状态码，如需要则返回新的资源。

:::

## React
> 这里收录一些react的面试题

## 工程化
> 这里收录一些工程化的面试题

### webpack中file-loader和url-loader的区别

二者都是用于处理文件，url-loader时file-loader的封装
- file-loader: 不对文件进行处理只用于复制文件，将文件复制到目标路径下
- url-loader：可以将小文件转成base64格式

### webpack和vite的区别
``webpack``和``vite``都是现代工程化构建工具，二者出于不同的设计理念。主要区别在于开发环境

开发环境：``webpack``本质上是一个模块打包器，他把项目中的所有模块都打包成一个或者多个``bundle``，在处理大项目时由于``webpack``需要构建完所有模块才能产出构建产物，所以通常来说速度会很慢，而``vite``
采用浏览器支持``esmodule``导入的特性，在开发阶段只对依赖进行与构建（产出每个依赖和他的路径的映射表）。在浏览器需遇到``import``语句的时候会去发起请求，``vite``这时动态的去构建被请求的文件 并且响应给浏览器由此完成整个链路。
也就是说``vite``并不需要在项目启动时就构建完所有的文件 而是浏览器用到了哪个他才去构建哪个，这也就是为什么``vite``开发环境速度飞快的原因。

生产环境：``vite``生产环境和``webpack``大同小异，也是需要构建所有的产物，值得注意的时``vite``在生产环境采用的时``rollup``，而开发环境采用的时``esbuild``去构建

### vite衍生问题：esbuild和rollup的区别
``esbuild``由``GO``编写，速度由于``rollup``，并且他对跨平台的支持和多语言的支持更加良好，使用起来简单。``rollup``是一个专注``es``模块的打包器，它使用``es``语法来打包代码，他的摇树优化非常优秀，打包速度也很快并且支持输出不同格式的模块代码如``ESM``,``CommonJS``,``UMD``。
``vite``在开发环境选择``esbuild``是为了快速相应浏览器的请求，而生产阶段用``rollup``则是更好的支持构建。



